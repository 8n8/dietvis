title { `Diet` }
author { `True Ghiassi` }
date { `12 April 2022` }
body {
header 1 x { `Introduction` }
`Diet is a computer program for tracking meals and body measurements. Its purpose is to help me lose weight by reducing calorie consumption.`
p
`This document is a complete specification of the system.`

header 1 x { `Hardware requirements` }
`It needs to be able to run on my phone, which is a low-end Android phone. This is because I need to be able to enter data on it wherever I am, such as when I am downstairs eating lunch in the dining room.`
p
`I would also like to be able to use it on my 17-inch laptop.`
p
`So it needs to work in Firefox Mobile browser and Chrome desktop browser.`

header 1 x { `User requirements` }

`I need to be able to enter data with as little time and effort as possible, to make it less likely that I will lapse from the diet.`
p
`It would be good if it could be used by others too, so should be well documented and laid out in a familiar way.`
p
`It needs to store foods that I have entered, so that I can easily reuse them without looking up the calories again. It should have common food definitions built in.`
p
`I need to be able to view charts of my weight and waist measurements, and also of the 5-day running average of these measurements, as they fluctuate a lot from day to day.`

header 1 x { `Sketchs of user interface` }

`The top part of the user interface is for viewing the total calories consumed in the last 24 hours, and for entering data.`

image uiTop `0.7` { `Sketch of top part of the interface` } `guitop.png`

`The lower part of the user interface contains charts of the data and buttons for downloading and uploading it.`

image uiBottom `0.7` { `Sketch of lower part of the interface` } `guibottom.png`

header 1 x { `Data storage` }
`The stored data is:`
bullets {
{ `custom foods` }
{ `meals` }
{ `weight measurements` }
{ `waist measurements` }
}
`Data is stored in the browser in localstorage. The data store is passed in as a flag on initialization, and kept in the Elm Model. Whenever this data is changed in the Model, Elm encodes the whole data set to binary and sends it through a port as a Base 64 string. On the JS side this new data overwrites the old data.`

header 1 x { `Meals` }
`A meal is:`
bullets {
{ `an integer ID` }
{ `the amount of food that was eaten` }
{ `the calories in the food` }
{ `the date and time it was eaten` }
}
`The meals are an Elm record of three equal length arrays, with the integer ID as the index. Meals can be added, removed or modified.`
p
`The size of a meal should be ` math { 3 * 8 = 24 ` bytes` } `, although perhaps Elm / JS adds some extra overhead. That is, four 8-byte integers.`
p
`The set of meals can be empty, and can be created by adding them one at a time, or by decoding them from store.`
p
`The meal set can be used to calculate the number of calories consumed in the last 24 hours.`

header 1 x { `Foods` }
`A food is a name and the calorie rate for the food. No two foods can have the same name.`
p
`There are custom foods, which are created by the user, and built-in foods, which are the Foundation Foods data set from ` url `https://fdc.nal.usda.gov/download-datasets.html` `.`
p
`The custom foods data set can be empty, and can be created from a decoder. Custom foods can be added to the set, removed, and edited.` 
p
`Built-in foods cannot be changed in any way.`
p
`Foods are stored as an Elm Dict, with the names as keys and the calorie rates as values. Custom foods and built-in foods are kept in separate Dicts in separate modules. The built-in food Dict is generated by a Python script that parses the raw JSON file from the link above.`

header 1 bodyWeightMeasurements { `Body weight measurements` }
`A body weight measurement is:`
bullets {
{ `an integer ID` }
{ `a body weight` }
{ `a timestamp` }
}
`The body weight measurements set can be empty, and can be created from a decoder. Measurements can be added, removed and edited.`
p
`A body weight measurement is two 8-byte integers, so is 16 bytes.`
p
`The measurements are stored in two arrays: one for the weights, and the other for the timestamps. The arrays are the same length. The ID is the array index.`
p
`The reason for taking body weight measurements is to view them on a graph. So they must be viewable as a graph, with time on the ` math { x } `-axis and mass on the ` math { y } `-axis. The graph should be a scatter of the points, with a smooth 5-day average line plotted on top.`

header 1 x { `Waist measurements` }
`These are the same as body weight measurements, see ` ref bodyWeightMeasurements `, but with a waist size instead of a body weight.`

header 1 x { `Waist measurement ID` }
`The same as a body weight measurement ID, see ` ref bodyWeightId `, but for waists instead.`

header 1 x { `Waist size` }
`The smallest meaningful difference between waist sizes is 0.5 cm. It seems unlikely that anyone would have a waist of less than 20cm, so let ` math { 20 / 0.5 = 40 } ` be the smallest allowed size. It seems unlikely that someone would have a waist greater than 400 cm, so let ` math { 400 / 0.5 = 800 } ` be the highest value.`
p
`A waist size can be created from a decoder, or from a Unicode string of cm, such as '100'.`

header 1 bodyWeightId { `Body weight measurement ID` }

`A body weight measurement ID is an integer. Its minimum value is zero. Its maximum value should be high enough that years of measurements can have unique IDs. Say the user records 2 measurements a day for 50 years, that is ` math { 2 * 365 * 50 = 36500 } `. Since a body weight measurement takes up 16 bytes, the largest possible size for the set is ` math { 36500 * 16 ~= 1 ` MB` } `.`
p
`It can only be created by adding an item to a set of body weights or from a decoder.`

header 1 x { `Body mass` }

`The smallest meaningful difference between body masses is 100g, because I don't care about variations smaller than that.`
p
`It seems unlikely that there would be anyone weighing less than 10kg who is trying to lose weight. Let the lowest body mass be 100 (10 kg). Then 101 is 10.1 kg, 102 is 10.2 kg and so on.`
p
`It seems unlikely that there would be many people heavier than 30 stone, so let the the highest value be:`
Math {
equation { 30 * 7 * 10 = 2100 }
}
`(There are roughly 7 kg in a stone.)`
p
`A body mass can be created from a decoder, or from a Unicode string of kg, such as '75.2'.`

header 1 x { `Meal ID` }
`A meal ID is an integer. Its minimum value is zero. Its maximum value should be high enough that years of meals can have unique IDs. Say a person records 10 meals per day for 50 years, that is ` math { 10 * 365 * 50 = 182500 } `. So the maximum size of all the meals is ` math { 182500 * 24 ` B` ~= 4 ` MB` } `. This should comfortably fit in memory even on a low-end phone.`

header 1 x { `Food name` }
`The name of a food is a sequence of between 1 and 100 characters, where each character is one of:`
bullets {
{ `a-z` }
{ `0-9` }
{ `the space character, but not at the beginning or end, and not more than one at a time` }
}
`A food name is encoded using UTF-8. A food name can be created from a Unicode string which meets the requirements above.`

header 1 x { `Meal mass` }
`A meal mass is represented as an integer. The smallest meaningful difference between meal masses is 5g. So a meal mass of 1 is 5g, 2 is 10g etc. The lowest allowed value is 1 as it doesn't make sense to have a meal with zero mass. The upper limit should be large enough that it can store a single large meal, say a maximum of 5kg of food, so is ` math { 5 * 1000 `g` / 5 `g` = 1000 } `. There is no need to add meals together, so it only needs to be high enough to contain one meal.`
p
`A meal mass can be created from a UTF-8 string containing grams, such as '120' , or from a binary.`

header 1 x { `Food calorie rate` }
`The calories in a food has units Energy / Mass. The smallest meaningful difference between two values is 5 kCal / 100g. The value is stored as an integer. The lowest value is 1, as a food with zero calories, like water, doesn't need to go in the system. So 1 is 5 kCal / 100g, 2 is 10 kCal / 100g, and so on.`
p
`The highest calorie food I know of is olive oil with 884 kCal / 100g. It seems unlikely that there is anything higher than 2000 kCal / 100g.`
Math {
equation { 2000 / 5 = 400 }
}
`so the internal representation has a maximum value of 400.`
p
`A food calories rate can be created from a Unicode string containing kCal / 100g, such as '58', and also from a binary decoder.`

header 1 x { `Date and time` }
`Timestamps are needed for:`
bullets {
{ `viewing body weight and waist as a time series` }
{ `calculating the total calories consumed in the last 24 hours` }
}
`The smallest meaningful difference between two time values in this context is 1 hour. The minimum time is zero, which corresponds to Posix time 1649535010, which is the Posix time as of the time of writing. Let the highest possible value be 100 years from now:`
Math {
equation { 100 * 365 * 24 = 876000 }
}
`Time can be created only by an Elm task or from a decoder. So measurements must be entered as they happen, and time fields can't be edited.`
}
